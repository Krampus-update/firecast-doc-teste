# Objeto SceneViewport

# Objeto SceneViewport

O Objeto Viewport representa a tela do usuário, a janela de exibição, onde o scene está sendo renderizado.

&nbsp;

O Viewport de um scene pode ser obtido através da propriedade "[viewport](<ObjetoScene.md#prop%20viewport>)" do [objeto Scene](<ObjetoScene.md>)

&nbsp;

&nbsp;

## Herança

O o**bjeto SceneViewport** herda de [SceneBaseObject](<ObjetoSceneBaseObject.md>) e possui também todas as suas características.

&nbsp;

## Características

Além das características herdadas, o objeto SceneViewport também possui as seguintes características:

### Propriedades e atributos

| **Propriedade** | Tipo | Descrição |
| --- | --- | --- |
| **scene** | [Objeto Scene](<ObjetoScene.md>) | (Somente Leitura) Contém o [Objeto Scene](<ObjetoScene.md>) que este Viewport renderiza.&nbsp; |
| **width** | Double | (Somente Leitura) Contem a LARGURA em [Métrica de Tela](<MetricadoMundovsMetricadaTela.md>) do viewport, isto é, da janela onde o scene está sendo renderizado.&nbsp; |
| **height** | Double | (Somente Leitura) Contem a ALTURA em [Métrica de Tela](<MetricadoMundovsMetricadaTela.md>) do viewport, isto é, da janela onde o scene está sendo renderizado. &nbsp; |
| **worldX** | Double | Define, em [Métrica de Mundo](<MetricadoMundovsMetricadaTela.md>), em qual posição do eixo X do mundo o ponto (X: 0, Y: 0) da tela aponta.&nbsp; As propriedades "worldX" e "worldY" servem para fazer "scroll" no scene.&nbsp; Se quiser fazer um scroll para a direita, por exemplo, incrementa-se o valor de worldX. Se quiser fazer um scroll para cima, decrementa-se o valor de worldY;&nbsp; Este é um valor local e não é compartilhado com os outros usuários que estão visualizando o mesmo scene.&nbsp; |
| **worldY** | Double | Define, em [Métrica de Mundo](<MetricadoMundovsMetricadaTela.md>), em qual posição do eixo Y do mundo o ponto (X: 0, Y: 0) da tela aponta.&nbsp; As propriedades "worldX" e "worldY" servem para fazer "scroll" no scene.&nbsp; Se quiser fazer um scroll para a direita, por exemplo, incrementa-se o valor de worldX. Se quiser fazer um scroll para cima, decrementa-se o valor de worldY;&nbsp; Este é um valor local e não é compartilhado com os outros usuários que estão visualizando o mesmo scene.&nbsp; |
| **scale** | Double | Define a escala entre a [Métrica do Mundo](<MetricadoMundovsMetricadaTela.md>) e a [Métrica da Tela](<MetricadoMundovsMetricadaTela.md>) do Scene.&nbsp; Em outras palavras, esta propriedade controla o "zoom" do Scene.&nbsp; Exemplo: Um valor 32.0 significa que cada unidade métrica do mundo ocupam 32 unidades métricas de tela.&nbsp; Se quiser, por exemplo, efetuar um zoom+ no scene, incrementa-se "scale". Se quiser reduzir o zoom pela metade, divide-se por dois o valor de "scale".&nbsp; Este é um valor local e não é compartilhado com os outros usuários que estão visualizando o mesmo scene.&nbsp; |
| **cursor** | Enumerado: "default" "arrow" "handPoint" "hourGlass" "IBeam" "size" "sizeNESW" "sizeNS" "sizeNWSE" "sizeWE" "upArrow" "drag" "noDrop" "hSplit" "vSplit" "multiDrag" "sqlWait" "no" "appStart" "help" "cross" | Define qual cursor de mouse deve ser apresentado quando o mouse estiver em em cima do viewport do scene.&nbsp; "default" - Cursor padrão, uma seta padrão. "arrow" - Uma seta padrão. "handPoint" - Uma mão com um dedo apontando para cima. Normalmente é usado para identificar um item selecionável/clicável "hourGlass" - Uma ampulheta para indicar um processo em andamento. "IBeam" - Cursor que sinaliza a possibilidade de entrar com texto no controle. "size" - Indicação de possibilidade de redimensionamento. "sizeNESW" - Indicação de possibilidade de redimensionamento no sentido Nordeste-Sudoeste "sizeNS" - Indicação de possibilidade de redimensionamento no sentido Norte-Sul "sizeNWSE" - Indicação de possibilidade de redimensionamento no sentido Noroeste-Sudeste "sizeWE" - Indicação de possibilidade de redimensionamento no sentido Leste-Oeste "upArrow" - Uma seta apontando para cima. "drag" - Um cursor indicando que itens estão sendo arrastados. "noDrop" - Indicação de que não é possível arrastar para este alvo. "hSplit" -&nbsp; Indicação de splitter horizontal "vSplit" - Indicação de splitter vertical. "multiDrag" - Indicação de que vários itens estão sendo arrastados. "sqlWait" - Ampulheta indicando um processo de banco de dados em andamento. "no" - Uma indicação de negação, de que não é possível fazer algo. "appStart" - Combinação de "default" e "hourGlass", normalmente usado para indicar que um aplicativo está sendo aberto. "help" - Uma seta com um ponto de interrogação. "cross" - Um cursor em formato de cruz, usado para indicar um posicionamento preciso.&nbsp; |


&nbsp;

&nbsp;

### Métodos

| **Método** | Descrição |
| --- | --- |
| **viewport:screenToWorld(screenX, screenY)** | Converte uma posição definida em [métricas de tela](<MetricadoMundovsMetricadaTela.md>) em uma posição definida em [métricas de mundo](<MetricadoMundovsMetricadaTela.md>).&nbsp; Em outras palavras, esta função responde a seguinte pergunta: O ponto (screenX, screenY) da tela do usuário representa qual ponto (worldX, worldY) do tabuleiro?&nbsp; Esta conversão leva em consideração o "scroll" e o "zoom" (propriedades worldX, worldY e scale) do Viewport.&nbsp; Parâmetros: screenX - a posição do eixo X do ponto da tela screenY - a posição do eixo Y do ponto da tela&nbsp; Retorno: Esta função retorna 2 valores na seguinte ordem: worldX e worldY contendo o ponto convertido em métricas de mundo.&nbsp; Exemplo de uso: local worldX, worldY = scene.viewport:screenToWorld(10, 50);&nbsp; |
| **viewport:screenToWorld(screenRect)** | Converte um retângulo definido em [métricas de tela](<MetricadoMundovsMetricadaTela.md>) em um retângulo definido em [métricas de mundo](<MetricadoMundovsMetricadaTela.md>).&nbsp; Em outras palavras, esta função responde a seguinte pergunta: O retângulo "screenRect" da tela do usuário representa qual retângulo do tabuleiro?&nbsp; Esta conversão leva em consideração o "scroll" e o "zoom" (propriedades worldX, worldY e scale) do Viewport.&nbsp; Parâmetros: screenRect - Uma [tabela SceneRect](<EstruturaSceneRect.md>) contendo o retângulo que será convertido.&nbsp; Retorno: Uma [tabela SceneRect](<EstruturaSceneRect.md>) contendo o retângulo convertido em métricas de mundo.&nbsp; |
| **viewport:worldToScreen(worldX, worldY)** | Converte uma posição definida em [métricas de mundo](<MetricadoMundovsMetricadaTela.md>) em uma posição definida em [métricas de tela](<MetricadoMundovsMetricadaTela.md>).&nbsp; Em outras palavras, esta função responde a seguinte pergunta: O ponto (worldX, worldY) do mundo do scene fica em qual posição (screenX, screenY) na tela do usuário?&nbsp; Esta conversão leva em consideração o "scroll" e o "zoom" (propriedades worldX, worldY e scale) do Viewport.&nbsp; Parâmetros: worldX - a posição do eixo X do mundo do scene. worldY - a posição do eixo Y do mundo do scene.&nbsp; Retorno: Esta função retorna 2 valores na seguinte ordem: screenX e screenY contendo o ponto convertido em [métricas de tela](<MetricadoMundovsMetricadaTela.md>).&nbsp; Exemplo de uso: local screenX, screenY = scene.viewport:worldToScreen(3, 4.5);&nbsp; |
| **viewport:worldToScreen(worldRect)** | Converte um retângulo definido em [métricas de mundo](<MetricadoMundovsMetricadaTela.md>) em um retângulo definido em [métricas de tela](<MetricadoMundovsMetricadaTela.md>).&nbsp; Em outras palavras, esta função responde a seguinte pergunta: O retângulo "worldRect" do mundo do scene ocupa qual retângulo da tela do usuário?&nbsp; Esta conversão leva em consideração o "scroll" e o "zoom" (propriedades worldX, worldY e scale) do Viewport.&nbsp; Parâmetros: worldRect - Uma [tabela SceneRect](<EstruturaSceneRect.md>) contendo o retângulo que será convertido.&nbsp; Retorno: Uma [tabela SceneRect](<EstruturaSceneRect.md>) contendo o retângulo convertido em métricas de tela.&nbsp; |
| **viewport:getScrollBounds()**&nbsp; | Retorna os limites de scroll para os valores worldX e worldY.&nbsp; Retorno: Esta função retorna 4 valores numéricos na seguinte ordem e definição: minX - Um número. O scene não deixa a propriedade worldX ficar menor que este valor. minY - Um número. O scene não deixa a propriedade worldY ficar menor que este valor; maxX - Um número. O scene não deixa a propriedade worldX ficar maior que este valor. maxY - Um número. O scene não deixa a propriedade worldY ficar maior que este valor.&nbsp; Exemplo de uso: local minX, minY, maxX, maxY = viewport:getScrollBounds(); &nbsp; |
| **viewport:setupToolCategory(name, title, order)** | Atualiza ou cria uma categoria de ferramentas no Scene.&nbsp; Parâmetros: name - Uma cadeia de caracteres contendo o nome da categoria. Este nome pode ser referenciado depois pela função [addToolButton](<ObjetoSceneViewport.md#addToolButton()>) title - Uma cadeia de caracteres contendo a descrição/título da categoria. order - Um número definindo a ordem da categoria. Esta categoria será exibida depois/abaixo de outra categoria de ordem menor. (A grosso modo, quem tiver número de ordem menor fica na frente)&nbsp; |
| **viewport:addToolButton(categoryName, title, &nbsp; iconURL, order, options, callback \[, deactivationCallback\])** | Adiciona um botão-ferramenta ao Scene.&nbsp; Parâmetros: categoryName - O nome da categoria em que o botão deve ser inserido. Este é o mesmo nome usado na função [setupToolCategory](<ObjetoSceneViewport.md#setupToolCategory>). Se for especificado uma categoria inexistente, ela será criada. title - Cadeia de caracteres contendo o título do botão. iconURL - Cadeia de caracteres contendo o endereço/caminho de uma imagem que será utilizada como ícone da ferramenta. Pode ser um endereço de internet (exemplo: “[http://xxxx.com.br/a.png](<http://xxxx.com.br/a.png>)”)&nbsp; Pode ser o caminho de um arquivo contido no pacote do plugin. Pode ser um arquivo que se encontra no [HD Virtual](<HDVirtual.md>) do plugin instalado. order - Um número contendo a ordem do botão em sua categoria. A grosso modo, quem tiver um número de ordem menor fica na frente. options - **nil** ou uma tabela LUA podendo conter os seguintes atributos: "selectable" - Booleano, onde true significa que a ferramenta é uma ferramenta selecionável. Uma ferramenta selecionável permanece ativa até que fique "não selecionada". Por padrão, este valor é false e significa que a ferramenta executa algo que não precisa mudar seleção da ferramenta ativa. defaultOfCategory - Booleano onde true significa que esta ferramenta é a padrão da categoria que está e que ela será utilizada quando o usuário clicar na categoria. O padrão é false. dontFocus - Booleano onde true significa que a ferramenta não deve ser focada como ferramenta padrão da categoria após o usuário clicar nela. O padrão é false. DontFocus não funciona se selectable estiver ativo. callback - Uma função que será chamada quando o usuário ativar/clicar esta ferramenta. (OPCIONAL) deactivationCallback - Uma função que será chamada quando esta ferramenta estava selecionada e o usuário selecionou outra. Este callback é chamado apenas se a ferramenta for do tipo "selecionável" e o Scene espera que sua ferramenta pare de fazer o que ela faz quando selecionada.&nbsp; Retorno: Esta função retorna um número identificador do ToolButton no scene. Este mesmo valor pode ser utilizado posteriormente na função [removeToolButton](<ObjetoSceneViewport.md#removeToolButton()>).&nbsp; |
| **viewport:removeToolButton(toolID)** | Remove um botão ferramenta que foi previamente adicionado pela função [addToolButton](<ObjetoSceneViewport.md#addToolButton()>).&nbsp; Parâmetros: toolID - Um número identificador do ToolButton. Este valor é retornado pela função addToolButton.&nbsp; |
| **viewport:checkToolButton(toolID\[, checked\])** | Marca ou desmarca um ToolButton. A marcação é uma mera indicação visual para o usuário entender que o Tool está ativo de alguma forma.&nbsp; Podem existir mais de 1 ToolButton marcados ao mesmo tempo.&nbsp; Parâmetros: toolID - toolID - Um número identificador do ToolButton. Este valor é retornado pela função addToolButton. (OPCIONAL) checked - Um booleano, onde **true** significa marcar o tool button e **false** significa desmarcar o tool button. Se não informado, true será utilizado como padrão.&nbsp; |
| **viewport:isToolButtonChecked(toolID)** | Retorna se um determinado ToolButto está marcado. A marcação é uma mera indicação visual para o usuário entender que o Tool está ativo de alguma forma.&nbsp; Podem existir mais de 1 ToolButton marcados ao mesmo tempo.&nbsp; Parâmetros: toolID - toolID - Um número identificador do ToolButton. Este valor é retornado pela função addToolButton.&nbsp; Retorno: Um Boolean, onde **true** significa que o toolbutton está marcado.&nbsp; |
| **viewport:selectDefaultToolButton()** | Seleciona a Ferramenta/Tool Button padrão. Pode existir apenas uma ferramenta selecionada ao mesmo tempo e representa a ferramenta que o usuário está trabalhando no momento.&nbsp; A ferramenta padrão normalmente é a de "selecionar/movimentar" itens do scene.&nbsp; |
| **viewport:selectToolButton(toolID)** | Seleciona a Ferramenta/Tool Button especificada pelo padrão. Pode existir apenas uma ferramenta selecionada ao mesmo tempo e representa a ferramenta que o usuário está trabalhando no momento.&nbsp; Parâmetros: toolID - toolID - Um número identificador do ToolButton. Este valor é retornado pela função addToolButton.&nbsp; |
| **viewport:showForm(form\[, options\])** | Exibe uma janela na interface do usuário na forma de um Popup flutuante acima do viewport do scene.&nbsp; Parâmetros: form - O formulário a ser exibido na interface. Deve ser um [objeto Lua Form já instanciado.](<Tagform.md>) (OPCIONAL) options - Uma tabela/objeto LUA contendo as opções da exibição do popup. As opções são: onClose - \[function, padrão = nil\] - Uma função lua que será invocada quando o popup for fechado. placement - \[string enumerado\] - Onde o popup será exibido.. Os possíveis valores são: "center" - no centro da tela "bottom" - na parte de baixo da tela "top" - na parte de cima da tela "left" - à esquerda na tela "right" - à direita na tela "topLeft" -&nbsp; no canto superior esquerdo da tela "topRight - no canto superior direito da tela "bottomLeft" - no canto inferior esquerdo da tela "bottomRight" - no canto inferior direito da tela "mouse" - onde o mouse está atualmente "mouseCenter" - centralizado onde o mouse está atualmente. nil ou não informado - Posição personalizada.&nbsp; &nbsp; &nbsp; Retorno:&nbsp; &nbsp; &nbsp; Se conseguir exibir o form como um popup no viewport, retorna **true**; Senão retorna **false**.&nbsp; Observações: A função não espera o popup fechar para retornar. Após esta chamada, o código LUA continuará sua execução normal enquanto o form é mostrado.&nbsp; |
| **viewport:closeForm(form)** |  Fecha uma janela popup que foi previamente aberta pela da função viewport:showPopup.&nbsp; Parâmetros: form - O formulário a ser fechado/tirado da interface. Deve ser um [objeto Lua Form já instanciado](<Tagform.md>)&nbsp; &nbsp; &nbsp; Retorno:&nbsp; &nbsp; &nbsp; Se conseguir fechar o form, retorna **true**; Senão retorna **false**.&nbsp; |
| **viewport:needRepaint()** | Informa ao RRPG que o Scene precisa ser redesenhado.&nbsp; |


&nbsp;

&nbsp;

### Métodos para renderização

Todos os métodos listados abaixos são válidos APENAS dentro de eventos "onBeforeDraw"s e "OnAfterDraw"s

&nbsp;

| **Método** | Descrição |
| --- | --- |
| **viewport:prepareFill(color)** | Prepara o viewport para renderizar o preenchimento de polígonos com uma cor sólida.&nbsp; Parâmetros: color - uma [cadeia de caracteres contendo uma cor](<StringdecoresnoLuaForm.md>).&nbsp; Observações: Após chamar este método, os métodos viewport:fill\*\*\* utilizarão esta cor no desenho.&nbsp; |
| **viewport:prepareDraw(color \[, thickness, strokeCap, strokeJoin, strokeDash\])** | Prepara o viewport para renderizar o contorno de polígonos com uma cor sólida.&nbsp; Parâmetros: color -&nbsp; uma [cadeia de caracteres contendo uma cor](<StringdecoresnoLuaForm.md>). (OPCIONAL) thickness - A espessura do contorno [métrica de tela](<MetricadoMundovsMetricadaTela.md>). Se omitido, o valor padrão é 1.0; (OPCIONAL) strokeCap - Define o estilo gráfico usado ao desenhar o fim das linhas. Pode ser "flat" (linhas com pontas retangulares) ou "round" (linhas com pontas arredondadas). Se omitido, o valor padrão é "flat". (OPCIONAL) strokeJoin - Define o estilo gráfico usado ao juntar segmentos de linha em uma forma. Pode ser "miter" (As quinas/junções são "quadradas"), "round" (As quinas/junções são arredondadas) ou "bevel" (As quintas/junções são ligadas de forma diagonal). Se omitido, o valor padrão é "miter" (OPCIONAL) strokeDash - Define o estilo gráfico da linha. Pode ser "solid" (A linha é sólida), "dash" (A linha é tracejada), "dot" (A linha é feita de pontos), "dashDot" (A linha é alternada entre traços e pontos), ou "dashDotDot" (A linha é alternada entre traço, ponto e ponto). Se omitido, o valor padrão é "solid"&nbsp; Observações: Após chamar este método, os métodos viewport:draw\*\*\* utilizarão estas configurações.&nbsp; |
| **viewport:prepareFont(size \[,fontName, bold, italic, underline\])** | Prepara o viewport para preencher textos com uma determinada fonte.&nbsp; Parâmetros: size - Um número contendo o tamanho da fonte. Ex: 12 (OPCIONAL) fontName - O nome da fonte a ser usada. Se **nil**, uma fonte padrão será utilizada. (OPCIONAL) bold - True se desejar que a fonte esteja em negrito. (OPCIONAL) italic - True se desejar que a fonte esteja em itálico. (OPCIONAL) underline - True se desejar que a fonte esteja sublinhada.&nbsp; |
| **viewport:fillRect(left, top, right, bottom\[, opacity\])** | Desenha o preenchimento de um retângulo na tela do scene.&nbsp; Parâmetros: left - Posição esquerda (no eixo X) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o retângulo deve ser preenchido. top - Posição superior (no eixo Y) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o retângulo deve ser preenchido. right - Posição direita (no eixo X) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o retângulo deve ser preenchido. bottom - Posição inferior (no eixo Y) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o retângulo deve ser preenchido. (OPCIONAL) opacity - Um número entre 0.0 e 1.0 definindo a opacidade do desenho, onde 0.0 = totalmente transparente e 1.0 = totalmente opaco. Se este parâmetro não for informado, será utilizado 1.0.&nbsp; Observações: Para definir o material/cor do retângulo, invoque primeiro o método "prepareFill"&nbsp; |
| **viewport:fillEllipse(left, top, right, bottom\[, opacity\])** | Desenha o preenchimento de uma elipse/figura oval na tela do scene.&nbsp; Parâmetros: left - Posição esquerda (no eixo X) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a elipse deve ser preenchida. top - Posição superior (no eixo Y) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a elipse deve ser preenchida. right - Posição direita (no eixo X) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a elipse deve ser preenchida. bottom - Posição inferior (no eixo Y) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a elipse deve ser preenchida. (OPCIONAL) opacity - Um número entre 0.0 e 1.0 definindo a opacidade do desenho, onde 0.0 = totalmente transparente e 1.0 = totalmente opaco. Se este parâmetro não for informado, será utilizado 1.0.&nbsp; Observações: Para definir o material/cor da elipse, invoque primeiro o método "prepareFill"&nbsp; |
| **viewport:fillPolygon(polygon\[, opacity\])** | Desenha o preenchimento de um polígono na tela do scene.&nbsp; Parâmetros: polygon - Um array de tabelas que contém propriedades x e y, e cada cada item do array representando um vértice do polígono. (OPCIONAL) opacity - Um número entre 0.0 e 1.0 definindo a opacidade do desenho, onde 0.0 = totalmente transparente e 1.0 = totalmente opaco. Se este parâmetro não for informado, será utilizado 1.0.&nbsp; Observações: Para definir o material/cor do polígono, invoque primeiro o método "prepareFill"&nbsp; |
| **viewport:fillACell(i, j \[, opacity\])** | Desenha o preenchimento de uma célula do grid do scene.&nbsp; Parâmetros: i - a posição i da célula "Aij" j - a posição j da célula "Aij" (OPCIONAL) opacity - Um número entre 0.0 e 1.0 definindo a opacidade do desenho, onde 0.0 = totalmente transparente e 1.0 = totalmente opaco. Se este parâmetro não for informado, será utilizado 1.0.&nbsp; Observações: Para definir o material/cor do retângulo, invoque primeiro o método "prepareFill"&nbsp; |
| **viewport:drawRect(left, top, right, bottom\[, opacity\])** | Desenha o contorno de um retângulo na tela do scene.&nbsp; Parâmetros: left - Posição esquerda (no eixo X) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o retângulo deve ser preenchido. top - Posição superior (no eixo Y) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o retângulo deve ser preenchido. right - Posição direita (no eixo X) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o retângulo deve ser preenchido. bottom - Posição inferior (no eixo Y) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o retângulo deve ser preenchido. (OPCIONAL) opacity - Um número entre 0.0 e 1.0 definindo a opacidade do desenho, onde 0.0 = totalmente transparente e 1.0 = totalmente opaco. Se este parâmetro não for informado, será utilizado 1.0.&nbsp; Observações: Para definir o material/cor do retângulo, invoque primeiro o método "prepareDraw"&nbsp; |
| **viewport:drawEllipse(left, top, right, bottom\[, opacity\])**&nbsp; | Desenha o contorno de uma elipse/figura oval na tela do scene.&nbsp; Parâmetros: left - Posição esquerda (no eixo X) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a elipse deve ser preenchida. top - Posição superior (no eixo Y) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a elipse deve ser preenchida. right - Posição direita (no eixo X) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a elipse deve ser preenchida. bottom - Posição inferior (no eixo Y) em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a elipse deve ser preenchida. (OPCIONAL) opacity - Um número entre 0.0 e 1.0 definindo a opacidade do desenho, onde 0.0 = totalmente transparente e 1.0 = totalmente opaco. Se este parâmetro não for informado, será utilizado 1.0.&nbsp; Observações: Para definir o material/cor da elipse, invoque primeiro o método "prepareDraw"&nbsp; |
| **viewport:drawLine(startX, startY, endX, endY \[,opacity\])** | Desenha uma linha na tela do scene.&nbsp; Parâmetros: startX - Posição no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a linha deve se originar. startY - Posição no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a linha deve se originar. endX - Posição no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a linha deve finalizar. endY - Posição no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde a linha deve finalizar. (OPCIONAL) opacity - Um número entre 0.0 e 1.0 definindo a opacidade do desenho, onde 0.0 = totalmente transparente e 1.0 = totalmente opaco. Se este parâmetro não for informado, será utilizado 1.0.&nbsp; |
| **viewport:textSize(txt)** | Calcula o tamanho do texto usando a fonte configurada no viewport.&nbsp; Parâmetros: txt - A cadeia de caracteres que será medida.&nbsp; Retorno: x - A largura do texto em [métrica de tela](<MetricadoMundovsMetricadaTela.md>)&nbsp; y - A altura do texto em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) &nbsp; Observações: Para definir a fonte, invoque primeiro o método "prepareFont"&nbsp; |
| **viewport:fillText(x, y, txt \[, opacity\])** | Desenha um texto no scene.&nbsp; Parâmetros: x - Posição no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o texto deve começar a ser desenhado. y - Posição no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o texto deve começar a ser desenhado. txt - A cadeia de caracteres que será desenhada. (OPCIONAL) opacity - Um número entre 0.0 e 1.0 definindo a opacidade do desenho, onde 0.0 = totalmente transparente e 1.0 = totalmente opaco. Se este parâmetro não for informado, será utilizado 1.0.&nbsp; Observações: Para definir a fonte, invoque primeiro o método "prepareFont" Para definir o material/cor do texto, invoque primeiro o método "prepareFill"&nbsp; |
| **viewport:fillTextFit(x, y, right, bottom, txt\[, horzTextAlign, vertTextAlign, , opacity\])** | Desenha um texto no scene de forma a fazer cabe-lo da melhor forma em um retângulo definido.&nbsp; Parâmetros: x - Posição no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o texto deve começar a ser desenhado. y - Posição no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o texto deve começar a ser desenhado. right - Posição no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o texto deve começar a ser desenhado. txt - A cadeia de caracteres que será desenhada. (OPCIONAL) opacity - Um número entre 0.0 e 1.0 definindo a opacidade do desenho, onde 0.0 = totalmente transparente e 1.0 = totalmente opaco. Se este parâmetro não for informado, será utilizado 1.0.&nbsp; Observações: Para definir a fonte, invoque primeiro o método "prepareFont" Para definir o material/cor do texto, invoque primeiro o método "prepareFill"&nbsp; |
| **viewport:pushRenderState()** | Salva as configurações atuais de renderização para que possam ser restauradas mais tardes usando popRenderState.&nbsp; Observação: Para cada chamada de pushRenderState, deve haver uma chamada de popRenderState.&nbsp; |
| **viewport:popRenderState()** | Restaura as configurações de renderização previamente salvadas pelo método pushRenderState.&nbsp; Observação: Para cada chamada de pushRenderState, deve haver uma chamada de popRenderState.&nbsp; |
| **viewport:pushRotationTransform(angle, centerX, centerY)** | Empurra uma transformação de rotação no viewport.&nbsp; Parâmetros: angle - Angulo em graus da rotação que deve ser feita. centerX - Posição do pivô de rotação no eixo X em [métrica de tela.](<MetricadoMundovsMetricadaTela.md>) centerY - Posição do pivô de rotação no eixo Y em [métrica de tela.](<MetricadoMundovsMetricadaTela.md>)&nbsp; Observações: As próximas renderizações serão rotacionadas com esta configuração até a chamada de popTransform. Para cada chamada de pushRotationTransform deve haver uma chamada de popTransform.&nbsp; |
| **viewport:pushWorldToScreenTransform();** | Empurra uma transformação de coordenadas em [métrica de mundo](<MetricadoMundovsMetricadaTela.md>) para [métrica de tela](<MetricadoMundovsMetricadaTela.md>) no viewport.&nbsp; Após a chamada desta função, todos os métodos de desenho entenderão que as coordenadas passadas estão em métrica de mundo.&nbsp; Observações: Para cada chamada de pushWorldToScreenTransform deve haver uma chamada de popTransform.&nbsp; |
| **viewport:popTransform();** | Remove do viewport a última transformação que havia sido empurrada.&nbsp; |


&nbsp;

### Eventos

| **Nome do evento** | Descrição |
| --- | --- |
| **onChange** | Evento que é disparado quando o Viewport do scene mudar.&nbsp; As seguintes situações disparam este evento: Alteração no tamanho da tela (propriedades width e height) Alteração no scroll do viewport (propriedades worldX e worldY) Alteração no zoom do viewport (propriedade scale)&nbsp; |
| **onMouseDown** | Este evento é invocado quando um botão do mouse é pressionado sobre o Viewport ou quando o dedo toca a tela (touchscreen).&nbsp; Parâmetros: event - uma tabela Lua que contém os seguintes atributos: button – indica qual botão do mouse foi pressionado, e pode conter um dos seguintes valores: “left”, “middle” ou “right”... Quando o dedo é pressionado (touchscreen), este valor é “left” e isTouch = true. x – posição X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) indicando onde o mouse foi pressionado. y – posição Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) indicando onde o mouse foi pressionado. shiftKey - true se a tecla shift estiver pressionada também ctrlKey - true se a tecla control estiver pressionada também altKey - true se a tecla alt estiver pressionada também. isTouch - true se este evento foi disparado por causa de um dedo em um display touchscreen.&nbsp; |
| **onMouseMove** | Este evento é invocado quando o mouse se movimenta pelo viewport ou quando o dedo (touchscreen) é arrastado pelo viewport.&nbsp; Parâmetros: event - uma tabela Lua que contém os seguintes atributos: x – posição X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) indicando para onde o mouse moveu. y – posição Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) indicando para onde o mouse moveu. shiftKey - true se a tecla shift estiver pressionada também ctrlKey - true se a tecla control estiver pressionada também altKey - true se a tecla alt estiver pressionada também. isTouch - true se este evento foi disparado por causa de um dedo em um display touchscreen.&nbsp; |
| **onMouseUp** | Este evento é invocado quando um botão do mouse é liberado sobre o Viewport ou quando o dedo solta da tela (touchscreen).&nbsp; Parâmetros: event - uma tabela Lua que contém os seguintes atributos: button – indica qual botão do mouse foi liberado, e pode conter um dos seguintes valores: “left”, “middle” ou “right”... Quando o dedo é levantado (touchscreen), este valor é “left” e isTouch = true. x – posição X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) indicando onde o mouse foi liberado. y – posição Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) indicando onde o mouse foi liberado. shiftKey - true se a tecla shift estiver pressionada também ctrlKey - true se a tecla control estiver pressionada também altKey - true se a tecla alt estiver pressionada também. isTouch - true se este evento foi disparado por causa de um dedo em um display touchscreen.&nbsp; |
| **onMouseDblClick** | Este evento é invocado quando o usuário realiza a ação duplo clique com o mouse sobre o Viewport.&nbsp; Parâmetros: event - uma tabela Lua que contém os seguintes atributos: x – posição X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) indicando onde ocorreu o duplo clique. y – posição Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) indicando onde ocorreu o duplo clique. shiftKey - true se a tecla shift estiver pressionada também ctrlKey - true se a tecla control estiver pressionada também altKey - true se a tecla alt estiver pressionada também. isTouch - true se este evento foi disparado por causa de um dedo em um display touchscreen. &nbsp; Observação: Este evento é disparado junto com onMouseDown e onMouseUp na seguinte ordem: Mouse Down -\> Mouse Up -\> Mouse Down -\> Dbl Click -\> Mouse Up&nbsp; |
| **onMouseWheel** | Este evento é invocado quando a "rodinha" do mouse é é rolada sobre o Viewport.&nbsp; Parâmetros: event - uma tabela Lua que contém os seguintes atributos: delta - Um número que indica a distancia que a roda foi rodada. Se for positivo, significa que a rodinha foi rolada para cima e se for negativo significa que ela foi rolada para baixo.&nbsp; shiftKey - true se a tecla shift estiver pressionada também ctrlKey - true se a tecla control estiver pressionada também altKey - true se a tecla alt estiver pressionada também.&nbsp; Se seu evento controlou adequadamente este evento e não quer que nenhum outro plug-in tente manipular mais este evento, retorne explicitamente true usando "return true;"&nbsp; |
| **onFallbackMouseWheel** | Idêntico ao evento onMouseWheel, porém é chamado apenas quando nenhum código tratar o evento onMouseWheel.&nbsp; |
| **onGestureBeginZoom** | Este evento é invocado quando o usuário, utilizando o TouchScreen e seus dedos, começa a realizar um gesto de zoom.&nbsp; Parâmetros: x - Número, a posição CENTRAL no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi iniciado. Esta posição é o pivô do zoom. y - Número, a posição CENTRAL no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi iniciado. Esta posição é o pivô do zoom.&nbsp; Observações: Neste momento, o usuário ainda não realizou zoom, apenas destacou sua intenção de o fazer.&nbsp; Retorne explicitamente **true** para indicar ao Scene que você já lidou com este evento e nenhum outro script precisa se preocupar com ele.&nbsp; |
| **onGestureZoom** | Este evento é invocado quando o usuário, utilizando o TouchScreen e seus dedos, realiza um gesto de zoom.&nbsp; Parâmetros: x - Número, a posição CENTRAL no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi realizado. Esta posição é o pivô do zoom. y - Número, a posição CENTRAL no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi realizado. Esta posição é o pivô do zoom. delta - Um número contendo a distância em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) do zoom desejado. Se negativo, é um gesto de zoom out. Este valor é a variação da distância deste o último evento onGestureZoom.&nbsp; Retorne explicitamente **true** para indicar ao Scene que você já lidou com este evento e nenhum outro script precisa se preocupar com ele.&nbsp; |
| **onGestureEndZoom** | Este evento é invocado quando o usuário, utilizando o TouchScreen e seus dedos, finaliza um gesto de zoom.&nbsp; Parâmetros: x - Número, a posição CENTRAL no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi finalizado. Esta posição é o pivô do zoom. y - Número, a posição CENTRAL no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi finalizado. Esta posição é o pivô do zoom.&nbsp; Observações: Neste momento, o usuário já realizou todo zoom que queria fazer.&nbsp; Retorne explicitamente **true** para indicar ao Scene que você já lidou com este evento e nenhum outro script precisa se preocupar com ele.&nbsp; |
| **onGestureBeginRotation** | Este evento é invocado quando o usuário, utilizando o TouchScreen e seus dedos, começa a realizar um gesto de rotação.&nbsp; Parâmetros: x - Número, a posição CENTRAL no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi iniciado. Esta posição é o pivô da rotação. y - Número, a posição CENTRAL no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi iniciado. Esta posição é o pivô da rotação.&nbsp; Observações: Neste momento, o usuário ainda não realizou rotação, apenas destacou sua intenção de o fazer.&nbsp; Retorne explicitamente **true** para indicar ao Scene que você já lidou com este evento e nenhum outro script precisa se preocupar com ele.&nbsp; |
| **onGestureRotation** | Este evento é invocado quando o usuário, utilizando o TouchScreen e seus dedos, realiza um gesto de rotação.&nbsp; Parâmetros: x - Número, a posição CENTRAL no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi realizado. Esta posição é o pivô da rotação. y - Número, a posição CENTRAL no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi realizado. Esta posição é o pivô da rotação. angle - Número contendo o ângulo da rotação em graus. Valor positivo significa rotação em sentido anti-horário, valor negativo em sentido horário.&nbsp; Este valor é a variação do ângulo deste o último evento onGestureRotation.&nbsp; Retorne explicitamente **true** para indicar ao Scene que você já lidou com este evento e nenhum outro script precisa se preocupar com ele.&nbsp; |
| **onGestureEndRotation** | Este evento é invocado quando o usuário, utilizando o TouchScreen e seus dedos, finaliza um gesto de rotação.&nbsp; Parâmetros: x - Número, a posição CENTRAL no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi finalizado. Esta posição é o pivô da rotação. y - Número, a posição CENTRAL no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi finalizado. Esta posição é o pivô da rotação.&nbsp; Observações: Neste momento, o usuário já realizou toda rotação que queria fazer.&nbsp; Retorne explicitamente **true** para indicar ao Scene que você já lidou com este evento e nenhum outro script precisa se preocupar com ele.&nbsp; |
| **onGestureBeginPan** | Este evento é invocado quando o usuário, utilizando o TouchScreen e seus dedos, começa a realizar um gesto de deslize/scroll.&nbsp; Parâmetros: x - Número, a posição no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi iniciado. y - Número, a posição no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi iniciado.&nbsp; Observações: Neste momento, o usuário ainda não realizou deslizamento, apenas destacou sua intenção de o fazer.&nbsp; Retorne explicitamente **true** para indicar ao Scene que você já lidou com este evento e nenhum outro script precisa se preocupar com ele.&nbsp; |
| **onGesturePan** | Este evento é invocado quando o usuário, utilizando o TouchScreen e seus dedos, realiza um gesto de deslize/scroll.&nbsp; Parâmetros: x - Número, a posição no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi realizado. Este representa onde, no viewport, está o ponteiro/dedo. y - Número, a posição no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi realizado. Este representa onde, no viewport, está o ponteiro/dedo.&nbsp; Retorne explicitamente **true** para indicar ao Scene que você já lidou com este evento e nenhum outro script precisa se preocupar com ele.&nbsp; |
| **onGestureEndPan** | Este evento é invocado quando o usuário, utilizando o TouchScreen e seus dedos, finaliza um gesto de deslize/scroll.&nbsp; Parâmetros: x - Número, a posição no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi finalizado. y - Número, a posição no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi finalizado.&nbsp; Retorne explicitamente **true** para indicar ao Scene que você já lidou com este evento e nenhum outro script precisa se preocupar com ele.&nbsp; |
| **onGestureLongTap** | Este evento é invocado quando o usuário, utilizando o TouchScreen e seus dedos, realiza um gesto de longTap (pressionar e segurar por algum tempo)&nbsp; Parâmetros: x - Número, a posição no eixo X em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi realizado.&nbsp; y - Número, a posição no eixo Y em [métrica de tela](<MetricadoMundovsMetricadaTela.md>) de onde o gesto foi realizado.&nbsp; Retorne explicitamente **true** para indicar ao Scene que você já lidou com este evento e nenhum outro script precisa se preocupar com ele.&nbsp; |
| **onKeyDown** | Este evento é invocado quando uma tecla (teclado) é pressionada no Scene.&nbsp; Parâmetros: event - uma tabela Lua que contém os seguintes atributos key - Cadeia de caracteres contendo a letra do teclado que foi pressionada keyCode – Código numérico da tecla que foi pressionada (algumas teclas, como F7, por exemplo, não representam uma letra, daí a necessidade do keyCode) shiftKey - true se a tecla shift estiver pressionada também ctrlKey - true se a tecla control estiver pressionada também altKey - true se a tecla alt estiver pressionada também.&nbsp; Observações: Se você alterar o valor de key e/ou keyCode, a mudança é incorporada. Caso queira suprimir/ignorar a tecla que acabou de ser pressionada, atribua event.key = "" e event.keyCode = 0. Se a combinação de teclas pressionada puder ser um atalho, então event.key virá com valor "" (string vazio) e event.keyCode com valor diferente de 0. Se a combinação de teclas pressionada puder ser tratada como um caractere exibível, event.key vira com uma string contendo apenas este caracter e event.keyCode virá com valor igual a 0. &nbsp; |
| **onKeyUp** | Este evento é invocado quando uma tecla (teclado) é liberada.&nbsp; Parâmetros: event - uma tabela Lua que contém as mesmas propriedades descritas no [evento onKeyDown](<ObjetoSceneViewport.md#Evento%20OnKeyDown>) mas com informações sobre a tecla liberada.&nbsp; |
| **onBeforeDrawBkgLayer** | Evento de renderização. Quando estiver neste evento, utilize os [métodos de renderização do viewport](<ObjetoSceneViewport.md#Métodos%20para%20renderização>) para realizar pinturas na tela do usuário. Não realize tarefas pesadas neste evento\!&nbsp; Este evento é invocado antes do RRPG pintar a camada background do scene.&nbsp; |
| **onBeforeDrawGridLayer** | Evento de renderização. Quando estiver neste evento, utilize os [métodos de renderização do viewport](<ObjetoSceneViewport.md#Métodos%20para%20renderização>) para realizar pinturas na tela do usuário. Não realize tarefas pesadas neste evento\!&nbsp; Este evento é invocado depois do RRPG pintar a camada background e antes de pintar o grid do scene.&nbsp; |
| **onBeforeDrawObjsLayer** | Evento de renderização. Quando estiver neste evento, utilize os [métodos de renderização do viewport](<ObjetoSceneViewport.md#Métodos%20para%20renderização>) para realizar pinturas na tela do usuário. Não realize tarefas pesadas neste evento\!&nbsp; Este evento é invocado depois do RRPG pintar o grid e antes de pintar a camada objetos do scene.&nbsp; |
| **onBeforeDrawTokensLayer** | Evento de renderização. Quando estiver neste evento, utilize os [métodos de renderização do viewport](<ObjetoSceneViewport.md#Métodos%20para%20renderização>) para realizar pinturas na tela do usuário. Não realize tarefas pesadas neste evento\!&nbsp; Este evento é invocado depois do RRPG pintar a camada objetos e antes de pintar a camada tokens do scene.&nbsp; |
| **onAfterDrawLayers** | Evento de renderização. Quando estiver neste evento, utilize os [métodos de renderização do viewport](<ObjetoSceneViewport.md#Métodos%20para%20renderização>) para realizar pinturas na tela do usuário. Não realize tarefas pesadas neste evento\!&nbsp; Este evento é invocado depois do RRPG pintar a camada tokens.&nbsp; |
| **onStartDrop** | Evento que é chamado quando alguém arrasta uma informação (drag) em cima do scene e você deseja informar quais ações ou dados existem em um determinado ponto do tabuleiro.&nbsp; Parâmetros: drop - [Objeto Drop](<ObjetoDrop.md>) o qual você deve preencher as informações para o RRPG acasalar o drag com o drop. x - Numero contendo a posição do eixo X, em [métrica de tela](<MetricadoMundovsMetricadaTela.md>), de onde o drop está tentando ser feito. y - Numero contendo a posição do eixo y, em [métrica de tela](<MetricadoMundovsMetricadaTela.md>), de onde o drop está tentando ser feito. drag - [Objeto Drag](<ObjetoDrag.md>) representando a informação que está sendo arrastada. Você não deve alterar as propriedades deste objeto.&nbsp; Por favor, consulte [Arrastando-e-Soltando Informações / Drag and Drop](<ArrastandoeSoltandoInformacoesDr.md>) para conhecer melhor sobre o processo drag and drop.&nbsp; |


&nbsp;

## Exemplos

### Exemplo 1 - Um plugin que detecta quando o Viewport de um scene muda

&nbsp;

| require("scene.lua");   SceneLib.registerPlugin(     **function** (scene, attachment)                            scene.viewport.onChange =  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **function**()                 **local** r = scene.viewport:screenToWorld({left=0, top=0,                                                         right=scene.viewport.width,                                                         bottom=scene.viewport.height});                         **local** texto = "O Viewport mudou..**\\n**" ..                               "Dimensões da tela: "    .. scene.viewport.width .. " por " ..                               scene.viewport.height .. "**\\n**" ..                               "Posicao do Scroll: " .. scene.viewport.worldX .. " por " ..                               scene.viewport.worldY .. "**\\n**" ..                               "Região do Scene que é exibido neste viewport: " ..                               string.format("\[(left %f, top %f)(right %f, bottom %f)\]",                                             r.left, r.top, r.right, r.bottom);                                               showMessage(texto);             **end**;            **end**);&nbsp; |
| --- |


&nbsp;

### Exemplo 2 - Um plug-in que descobre em qual célula do grid o usuário clicou

&nbsp;

| require("scene.lua");   SceneLib.registerPlugin(     **function** (scene, attachment)                    *-- Manipular o evento onMouseUp do Viewport afim de detectar o click do mouse*                 scene.viewport.onMouseUp =             **function** (event)                 *-- Converter coordenada de tela do click para coordenada de mundo*                 **local** wx, wy = scene.viewport:screenToWorld(event.x,                                                             event.y);                                                                                                                                                     *-- Converter coordenada de mundo para coordenada do grid*                 **local** i, j = scene.grid:worldToCell(wx, wy);                                         *-- Exibir uma Mensagem sobre a célula clicada     *                 showMessage("Click na célula \[Linha " .. i ..                             ", Coluna " .. j .. "\]");             **end**;                   **end**); &nbsp; |
| --- |


&nbsp;

&nbsp;

### Exemplo 3 - Um plug-in que adiciona/remove uma marca personalizada quando o usuário clica nos itens do scene.

&nbsp;

| require("scene.lua");   SceneLib.registerPlugin(     **function** (scene, attachment)                                    *-- Manipular o evento OnMouseDown do Viewport*                 scene.viewport.onMouseDown = **function**(event)             *-- Usuário clicou no Scene*             *-- Transformar as coordenadas de tela em métrica de mundo*             **local** worldX, worldY = scene.viewport:screenToWorld(event.x, event.y);                         *-- Localizar o item que o usuário clicou*             **local** item = scene.items:itemAtPoint(worldX, worldY);                         **if** item ~= nil **then**                 *-- Encontrou um item na posição clicada.             *                 **local** NOME\_MINHA\_MARCA = "MarcaExemplo";                                 *-- Localizar uma operação gráfica neste item com o nosso nome*                 **local** opGrafica = item.canvas:findByName(NOME\_MINHA\_MARCA);                                 **if** opGrafica == nil **then**                     *--\[\[ A operação gráfica da minha marca ainda não*                         *existe neste token/item. Vamos criar \]\]*                                             opGrafica = item.canvas:addBitmap();                     opGrafica.name = NOME\_MINHA\_MARCA; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *-- Abaixo, URL da imagem da nossa marca.*                     opGrafica.url = "https://wiki.teamfortress.com/w/images/d/dd/Bleed\_drop.png?t=20110425044341";                     opGrafica.x = 0.25;                     opGrafica.width = 0.3;                     opGrafica.y = -0.1;                     opGrafica.height = 0.3;                     opGrafica.z = 10;                                       **else**                     *-- Vamos apagar nossa operação gráfica previamente criada*                     opGrafica:delete();                 **end**;             **end**;                    **end**;                     **end**);&nbsp; |
| --- |


&nbsp;

| ![Image](<lib/NewItem222.png>) Item sem a marca | ![Image](<lib/NewItem223.png>) Item com a marca |
| :---: | :---: |



***
_Created with the Personal Edition of HelpNDoc: [Simplify Your Help Documentation Process with a Help Authoring Tool](<https://www.helpauthoringsoftware.com/articles/what-is-a-help-authoring-tool/>)_
